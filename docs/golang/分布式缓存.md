# 分布式缓存
本内容是学习 7days golang - 分布式缓存 项目的记录与笔记。[原项目](https://github.com/geektutu/7days-golang/tree/master/gee-cache)是一个非常棒的项目。

# Day 0: 分布式缓存 的 why what how
缓存目的：第一次请求时将一些耗时操作的结果暂存，以后遇到相同的请求，直接返回暂存的数据。

缓存中最简单的莫过于存储在内存中的键值对缓存了。很容易想到使用 map 实现，那直接创建一个 map，每次有新数据就往 map 中插入不就好了，这不就是键值对缓存么？这样做有什么问题呢？
1. 内存不够  
   删掉一些？用什么策略去删除呢？LRU可能是一个不错的选择。
2. 读写冲突  
   对缓存的访问，一般不可能是串行的。**map 是没有并发保护的**，应对并发的场景，修改操作(包括新增，更新和删除)需要加锁。
3. 单机性能不足  
   单台计算机的资源是有限的，计算、存储等都是有限的。随着业务量和访问量的增加，单台机器很容易遇到瓶颈。
   > 如果利用多台计算机的资源，并行处理提高性能就要缓存应用能够支持分布式，这称为水平扩展(scale horizontally)。与水平扩展相对应的是垂直扩展(scale vertically)，即通过增加单个节点的计算、存储、带宽等，来提高系统的性能，硬件的成本和性能并非呈线性关系，大部分情况下，分布式系统是一个更优的选择。

本次学习的目标功能是：
+ 单机缓存和基于 HTTP 的分布式缓存
+ LRU 的缓存策略
+ 使用锁机制防止缓存击穿
+ 使用一致性哈希选择节点，实现负载均衡
+ 使用 protobuf 优化节点间二进制通信

# Day 1: 基于 LRU 策略的缓存
![](7day_cache/lru.jpg)
cache 的存储由列表 list 承担，并保留一个 key->*Element 的 map，用于快速存取、更新、删除。当访问某个元素，将其移动至队尾，复杂度为 O(1)

列表允许值是实现了 Value 接口的任意类型，该接口只包含了一个方法 Len() int，用于返回值所占用的内存大小